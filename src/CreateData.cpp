#include <fmt/color.h>
#include <fmt/core.h>

#include "FeatureExtraction.hpp"
#include "Parameters.hpp"
#include "TrenchDeposition.hpp"

int main() {
  using NumericType = double;
  constexpr int D = 2;

  // How long to run the process and at which intervals to do the extraction
  static constexpr NumericType processDuration = 5.0;
  static constexpr NumericType extractionInterval = 1.0;

  // The parameters we are interested in
  std::vector<NumericType> stickingProbabilities = {1., 0.8, 0.3, 0.1};
  std::vector<NumericType> taperAngles = {-15., -10, -5., 0., 5., 10., 15.};

  // The number of heights at which we are going to measure the diameter of the
  // trench
  static constexpr int numberOfSamples = 30;

  // The data we are going to store consists of stickingProbability,
  // taperAngle, time and the sampled geometry descriptors as provided by the
  // feature extraction.
  int InputDimension = 3;

  // Instantiate the featureExtraction
  auto featureExtraction =
      psSmartPointer<FeatureExtraction<NumericType, D>>::New();
  featureExtraction->setNumberOfSamples(numberOfSamples);

  // The locations at which the diameters are extracted (normalized to the
  // trench depth at each timestep)
  auto sampleLocations = featureExtraction->getSampleLocations();

  std::string filename = "data.csv";
  auto writer = psSmartPointer<psCSVWriter<NumericType>>::New(filename);

  // Creation of a descriptive/ detailed header
  std::string header = "taperAngle,stickingProbability,extractionStep,depth";
  for (unsigned i = 0; i < numberOfSamples - 1; ++i)
    header += ",diameter_" + std::to_string(i);

  header += "\nData generated by simple trench deposition example.\nRelative "
            "locations of diameter measurements:";
  header += "\n!" + join(sampleLocations.begin(), sampleLocations.end());
  header += "\n!InputDimension=" + std::to_string(InputDimension) +
            ",ExtractionInterval=" + std::to_string(extractionInterval);

  writer->setHeader(header);
  writer->initialize();

  for (auto taperAngle : taperAngles) {
    Parameters<NumericType> params;
    params.taperAngle = taperAngle;
    const NumericType offset =
        std::tan(params.taperAngle * rayInternal::PI / 180.) *
        params.trenchHeight;

    if (params.trenchWidth / 2. + offset <= params.gridDelta) {
      fmt::print(
          fmt::fg(fmt::color::yellow),
          "Warning: a trench with the provided height {:.3f} and taper angle "
          "{:+.3f} would have an initial opening size of less than one grid "
          "delta! Skipping.\n",
          params.trenchHeight, params.taperAngle);
      continue;
    }

    // Make sure that the trench sidewalls stay inside the simulation domain,
    // even if they are tapered.
    params.xExtent =
        2. * std::max(params.trenchWidth / 2 - offset + params.gridDelta,
                      params.xExtent / 2);

    for (auto stickingProbability : stickingProbabilities) {
      params.stickingProbability = stickingProbability;
      fmt::print("AR={:.3f}, taperAngle={:+.3f}, sticking probability={:.3f}\n",
                 params.trenchHeight / params.trenchWidth, params.taperAngle,
                 params.stickingProbability);

      // Using the advection callback, we can run the extraction at
      // certain pre-defined advection timesteps.
      NumericType deltaT = extractionInterval / params.stickingProbability;

      auto advectionCallback = psSmartPointer<AdvectionCallback<
          NumericType, D, decltype(featureExtraction)::element_type,
          decltype(writer)::element_type>>::New(deltaT);

      advectionCallback->setFeatureExtraction(featureExtraction);
      advectionCallback->setWriter(writer);
      advectionCallback->setPrefixData(std::vector<NumericType>{
          params.taperAngle, params.stickingProbability});

      auto geometry = psSmartPointer<psDomain<NumericType, D>>::New();
      psMakeTrench<NumericType, D>(geometry, params.gridDelta, params.xExtent,
                                   params.yExtent, params.trenchWidth,
                                   params.trenchHeight, params.taperAngle)
          .apply();

      executeProcess(geometry, params, advectionCallback);

      writer->flush();
    }
  }

  return EXIT_SUCCESS;
}