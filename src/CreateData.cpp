#include <fmt/color.h>
#include <fmt/core.h>

#include "DimensionExtraction.hpp"
#include "Parameters.hpp"
#include "TrenchDeposition.hpp"

int main() {
  using NumericType = double;
  constexpr int D = 2;

  // How long to run the process and at which intervals to do the extraction
  static constexpr NumericType processDuration = 5.0;
  static constexpr NumericType extractionInterval = 1.0;

  // The parameters we are interested in
  std::vector<NumericType> stickingProbabilities = {1., 0.8, 0.3, 0.1};
  std::vector<NumericType> taperAngles = {-15., -10, -5., 0., 5., 10., 15.};

  // The number of heights at which we are going to measure the diameter of the
  // trench
  static constexpr int numberOfSamples = 30;

  // Total number of timesteps during the advection process at which the
  // geometry parameters are extracted.
  static constexpr int numberOfTimesteps =
      processDuration / extractionInterval + 1;

  // The data we are going to store consists of stickingProbability,
  // taperAngle and the sampled geometry descriptors as provided by the
  // extractor.
  int InputDimension = 2;
  // int dataDimension =
  //     numberOfTimesteps * (numberOfSamples + 1) + InputDimension;
  fmt::print("Number of extraction timesteps: {}\n", numberOfTimesteps);

  // Instantiate the extractor
  auto extractor = psSmartPointer<DimensionExtraction<NumericType, D>>::New();
  extractor->setNumberOfSamples(numberOfSamples);

  // The locations at which the diameters are extracted (normalized to the
  // trench depth at each timestep)
  auto sampleLocations = extractor->getSampleLocations();

  std::string filename = "data.csv";
  auto writer = psSmartPointer<psCSVWriter<NumericType>>::New(filename);

  // Creation of a descriptive/ detailed header
  std::string header = "taperAngle,stickingProbability,";
  for (unsigned j = 0; j < numberOfTimesteps; ++j) {
    auto jstr = std::to_string(j);
    header += "time_" + jstr + ",depth_" + jstr;
    for (unsigned i = 0; i < numberOfSamples - 1; ++i) {
      header += ",diameter_" + jstr + "_" + std::to_string(i);
    }
    if (j != numberOfTimesteps - 1)
      header += ",";
  }
  header += "\nData generated by simple trench deposition example.\nRelative "
            "locations of diameter measurements:";
  header += "\n!" + join(sampleLocations.begin(), sampleLocations.end());
  header += "\n!InputDimension=" + std::to_string(InputDimension);

  writer->setHeader(header);
  writer->initialize();

  for (auto taperAngle : taperAngles) {
    Parameters<NumericType> params;
    params.taperAngle = taperAngle;
    const NumericType offset =
        std::tan(params.taperAngle * rayInternal::PI / 180.) *
        params.trenchHeight;

    if (params.trenchWidth / 2. + offset <= params.gridDelta) {
      fmt::print(
          fmt::fg(fmt::color::yellow),
          "Warning: a trench with the provided height {:.3f} and taper angle "
          "{:+.3f} would have an initial opening size of less than one grid "
          "delta! Skipping.\n",
          params.trenchHeight, params.taperAngle);
      continue;
    }

    params.xExtent =
        2. * std::max(params.trenchWidth / 2 - offset + params.gridDelta,
                      params.xExtent / 2);

    for (auto stickingProbability : stickingProbabilities) {
      params.stickingProbability = stickingProbability;
      fmt::print("AR={:.3f}, taperAngle={:+.3f}, sticking probability={:.3f}\n",
                 params.trenchHeight / params.trenchWidth, params.taperAngle,
                 params.stickingProbability);

      // Using the advection callback, we can run the extraction at
      // certain pre-defined advection tim esteps.
      NumericType deltaT = extractionInterval / params.stickingProbability;

      auto data = psSmartPointer<std::vector<NumericType>>::New();
      data->push_back(params.taperAngle);
      data->push_back(params.stickingProbability);

      auto advectionCallback =
          psSmartPointer<AdvectionCallback<NumericType, D>>::New(deltaT);

      advectionCallback->setExtractor(extractor);
      advectionCallback->setDataPtr(data);

      auto geometry = psSmartPointer<psDomain<NumericType, D>>::New();
      psMakeTrench<NumericType, D>(geometry, params.gridDelta, params.xExtent,
                                   params.yExtent, params.trenchWidth,
                                   params.trenchHeight, params.taperAngle)
          .apply();

      params.processTime = processDuration / params.stickingProbability;

      executeProcess<NumericType, D>(geometry, params, advectionCallback);

      writer->writeRow(*data);
      writer->flush();
    }
  }

  return EXIT_SUCCESS;
}